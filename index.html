<html>
  <html>
    <script src="./ckeditor/ckeditor.js"></script>
    <link rel="stylesheet" href="./ckeditor.css" />
  </html>
  <body>
  <pre id="log" style="position: absolute; left: 0; top: 0">

  </pre>
  <br>
  <br>
  <div id="content" contenteditable>
    <h1>This editor structures your article into chapters</h1>
    <p>Each chapter is a set of titles, text and media</p>
    <p>We try to guess where content should be split into chunks, but users have tight control over that too.</p>
  </div>

  <script>
    // Turn off automatic editor creation first.
    CKEDITOR.disableAutoInline = true;
    var editor = CKEDITOR.inline('content', {
      extraPlugins: 'structural',
      floatSpaceDockedOffsetY: 10
    });

    editor.on('key', function(e) {
      if (e.data.keyCode == 8) {
        var selection = editor.getSelection()
        var range = selection.getRanges()[ 0 ]
        if (range.startOffset > 0) return;
        var container = range.startContainer.$
        for (; container.parentNode; container = container.parentNode) {
          if (container.parentNode.firstChild != container)
            break;
          // remove manual section boundary
          if (container.parentNode.tagName == 'SECTION') {
            if (container.parentNode.classList.contains('forced')) {
              container.parentNode.classList.remove('forced');
              fix();
              return false;
            }
          }
        }
        return true;
      }
    }, null, null, -10);




split = function(editor, root) {
  var children = Array.prototype.slice.call(root.childNodes);
  var selection = editor.getSelection()
  var bookmark = selection.createBookmarks();
  var last;
  var prev;
  var selected = selection.getStartElement();
  if (selected) selected = selected.$;

  context = {}

  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.tagName == 'SECTION') {
      if (child.classList.contains('forced'))
        last = child;
      var current = child;
      var grandchildren = Array.prototype.slice.call(child.childNodes);
      for (var j = 0; j < grandchildren.length; j++) {
        last = place(last, prev, grandchildren[j], current, root, selected, context)
        if (last === current) {
          current = undefined;
        }
        prev = grandchildren[j];
      }
      if (current && !current.classList.contains('forced'))
        current.parentNode.removeChild(current)
      continue;
    }

    last = place(last, prev, child, null, root, null, context)
    prev = child;
  }
  if (selected) {
    if (context.reselected) {
      var range = editor.createRange();
      range.moveToElementEditStart( new CKEDITOR.dom.element(context.reselected ) );
      range.select( true );
      console.error(context.reselected)
    } else {
      while (selected.parentNode) {
        if (selected == document.body)
          editor.getSelection().selectBookmarks(bookmark);
        selected = selected.parentNode;
      }
    }
  }
}

isEmptyParagraph = function(child) {
  //if (child.tagName == 'P') {
    switch (child.textContent) {
      case '&nbsp;': case ' ': case '': case 'Â ':
        return true;
    }
  //}
}

isInside = function(element, another) {
  while (element) {
    if (element == another)
      return true;
    element = element.parentNode
  }
}
place = function(parent, previous, child, current, root, selected, context) {
  if (previous) {
    // start a new line after empty paragraph
    
    if (parent.firstChild == previous && isEmptyParagraph(previous)) {
      if (isInside(selected, previous)) {
        var removed = previous
        previous.parentNode.removeChild(previous)
        previous = undefined
      } else if (selected.previousSibling == previous && isEmptyParagraph(selected)) {
        debugger
        var inserted = previous
      } else {
        var focused = previous;
      }

    
    }
    if (!focused && !removed && (isInside(selected, child) && isEmptyParagraph(previous))) {
      
      var section = document.createElement('section');
      parent.parentNode.insertBefore(section, parent.nextSibling);
      section.appendChild(child)
      section.classList.add('forced')

      if (inserted) {
        if (!context.reselected)
          context.reselected = previous;
      } else {
        previous.parentNode.removeChild(previous)
      }

      return section;
    }
    if ((child.tagName == 'H1') || (child.tagName == 'H2' && (previous.tagName != 'H1'))) {
      var section = (current || document.createElement('section'));
      parent.parentNode.insertBefore(section, parent.nextSibling);
      section.appendChild(child);

      return section;
    }
  }
  
  if (!parent) parent = current || document.createElement('section')
  if (!parent.parentNode)
    root.appendChild(parent);
  if (child.parentNode != parent || (previous && previous.parentNode == parent && child.previousSibling != previous)) {
    parent.insertBefore(child, previous && previous.nextSibling)
  }
  if (removed ? removed == selected : focused) {
    if (!context.reselected)
      context.reselected = focused || child;
  }
  return parent;  

}


var lastSelected;
var locked;
function fix() {
  if (locked) {
    return editor.undoManager.snapshots.pop()
  }
  requestAnimationFrame(function() {
    editor.fire( 'lockSnapshot');
    locked = split(editor, window.content)
    editor.fire( 'unlockSnapshot' );
    var selection = editor.getSelection()
    var selected = selection.getStartElement();
    lastSelected = selected && selected.$;

    // if splitting triggers change, pop the snapshot
    locked = true;
    requestAnimationFrame(function() {
      locked = false
    }, 1)
  }, 1)
}


CKEDITOR.plugins.add( 'structural', {
  init: function(editor) {
    editor.on('change', fix)
    setTimeout(fix, 10)

    





    function addButton(commandName, styles, forms, icon) {

      editor.ui.addButton(commandName, { // add new button and bind our command
          label: "Add " + commandName,
          command: commandName,
          toolbar: 'structural',
          icon: icon || 'italic'
      });

      style = new CKEDITOR.style(styles)
      editor.attachStyleStateChange( style, function( state ) {
            !editor.readOnly && editor.getCommand( commandName ).setState( state );
          } );

      editor.addCommand( commandName, new CKEDITOR.styleCommand( style, {
            contentForms: forms
          } ) )
    }

    addButton('heading', { element: 'h1'}, ['h1'], 'h1')
    addButton('subtitle', { element: 'h2'}, ['h2'], 'h2')
    addButton('blockquote', { element: 'blockquote'}, ['blockquote'], 'bq')
  }
})
  </script>
  </body>
</html>